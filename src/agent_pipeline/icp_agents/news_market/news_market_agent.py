from agents import Agent, function_tool, Runner
from datetime import datetime, timedelta
from typing import List, Dict, Optional
from pydantic import BaseModel
from tavily import AsyncTavilyClient
import logging
from agent_pipeline.config.env_config import config
from agent_pipeline.utils.simple_cache import cached

logger = logging.getLogger(__name__)

class MarketQuestion(BaseModel):
    """Structure d'une question de march√© g√©n√©r√©e"""
    question: str
    category: str
    deadline: str
    reasoning: str
    confidence: float
    relevant_keywords: List[str]

class NewsMarketAgent:
    """Agent qui cr√©e de nouveaux march√©s bas√©s sur les actualit√©s"""
    
    MARKET_CATEGORIES = [
        "Technology",
        "Politics", 
        "Economics",
        "Sports",
        "Entertainment",
        "Climate",
        "Healthcare",
        "Crypto",
        "Business",
        "Science"
    ]
    
    def __init__(self, tavily_api_key: str = None):
        self.tavily_client = AsyncTavilyClient(api_key=tavily_api_key or config.TAVILY_API_KEY)
        self.console = None
        
        self.agent = Agent(
            model=config.get_openai_model(),
            deps_type=type(self),
            system_prompt=self._get_system_prompt(),
            tools=[self.search_trending_news, self.validate_market_question],
        )
    
    def _get_system_prompt(self):
        return f"""Vous √™tes un expert en cr√©ation de march√©s de pr√©diction bas√©s sur les actualit√©s.
        Votre r√¥le est d'analyser les tendances d'actualit√©s et de g√©n√©rer des questions de march√© 
        pertinentes et mesurables.
        
        Cat√©gories disponibles: {', '.join(self.MARKET_CATEGORIES)}
        
        Pour chaque actualit√©, vous devez:
        1. Identifier les √©v√©nements futurs mesurables
        2. Formuler des questions claires avec des √©ch√©ances pr√©cises
        3. √âviter les sujets controvers√©s ou sensibles
        4. Assurer que la question a une r√©ponse binaire claire (Oui/Non)
        5. Fournir un raisonnement sur pourquoi cette question est pertinente
        
        Exemples de bonnes questions:
        - "Tesla d√©passera-t-il 500 milliards de capitalisation avant fin 2025?"
        - "L'inflation US sera-t-elle sous les 3% en d√©cembre 2025?"
        - "Bitcoin atteindra-t-il 200 000$ avant juillet 2025?"
        
        √âvitez:
        - Questions subjectives ou d'opinion
        - √âv√©nements d√©j√† pass√©s
        - Questions sans √©ch√©ance claire
        - Sujets politiques controvers√©s"""
    
    @function_tool
    async def search_trending_news(self, category: str = "general") -> str:
        """Recherche les actualit√©s tendance dans une cat√©gorie"""
        try:
            if self.console:
                self.console.print(f"[dim]üì∞ Searching trending news in: {category}[/dim]")
            
            query = f"trending news {category} {datetime.now().strftime('%Y-%m')}"
            
            response = await self.tavily_client.asearch(
                query=query,
                search_depth="basic",
                max_results=8,
                include_domains=["reuters.com", "bloomberg.com", "techcrunch.com", "cnn.com"],
                include_answer=True
            )
            
            results = []
            if response.get('answer'):
                results.append(f"Trending Summary: {response['answer']}")
            
            for result in response.get('results', [])[:5]:
                title = result.get('title', 'No title')
                content = result.get('content', '')[:200] + "..."
                date = result.get('published_date', 'Unknown date')
                results.append(f"‚Ä¢ {title} ({date}): {content}")
            
            return "\n".join(results)
            
        except Exception as e:
            logger.error(f"Error searching trending news: {e}")
            return f"News search failed: {str(e)}"
    
    @function_tool
    async def validate_market_question(self, question: str) -> str:
        """Valide si une question est appropri√©e pour un march√© de pr√©diction"""
        validation_criteria = [
            "Has clear binary outcome (Yes/No)",
            "Has specific deadline",
            "Is measurable and verifiable", 
            "Is about future event",
            "Avoids controversial topics"
        ]
        
        # Logique basique de validation
        score = 0
        feedback = []
        
        if "?" in question and ("will" in question.lower() or "sera" in question.lower()):
            score += 1
            feedback.append("‚úì Clear question format")
        
        if any(word in question.lower() for word in ["by", "before", "end of", "until", "avant", "fin"]):
            score += 1
            feedback.append("‚úì Has deadline")
        
        if any(word in question.lower() for word in ["reach", "exceed", "above", "below", "atteindra", "d√©passer"]):
            score += 1
            feedback.append("‚úì Measurable outcome")
        
        # Ann√©es futures
        current_year = datetime.now().year
        if str(current_year + 1) in question or str(current_year + 2) in question:
            score += 1
            feedback.append("‚úì Future-focused")
        
        validation_result = f"Score: {score}/4\n" + "\n".join(feedback)
        return validation_result
    
    @cached(ttl_seconds=1800)  # 30 minutes cache
    async def generate_market_questions(self, category: str = "general", count: int = 3) -> List[MarketQuestion]:
        """G√©n√®re des questions de march√© bas√©es sur les actualit√©s d'une cat√©gorie"""
        
        if self.console:
            self.console.print(f"[yellow]üìà Generating {count} market questions for category: {category}[/yellow]")
        
        prompt = f"""
        Analysez les actualit√©s r√©centes dans la cat√©gorie "{category}" et g√©n√©rez {count} questions 
        de march√© de pr√©diction pertinentes.
        
        Chaque question doit:
        1. √ätre bas√©e sur des actualit√©s r√©centes et tendances
        2. Avoir une √©ch√©ance claire dans les 12 prochains mois
        3. √ätre mesurable et v√©rifiable
        4. Avoir une r√©ponse binaire (Oui/Non)
        5. √ätre d'int√©r√™t public
        
        Format de r√©ponse souhait√© pour chaque question:
        - Question: [la question compl√®te]
        - Cat√©gorie: {category}
        - √âch√©ance: [date limite]
        - Raisonnement: [pourquoi cette question est pertinente]
        - Mots-cl√©s: [mots-cl√©s pour le suivi]
        
        G√©n√©rez maintenant {count} questions bas√©es sur les actualit√©s r√©centes.
        """
        
        try:
            runner = Runner()
            result = await runner.run(self.agent, user_prompt=prompt, deps=self)
            
            # Parser la r√©ponse (impl√©mentation simplifi√©e)
            response_text = result.data if hasattr(result, 'data') else str(result)
            
            # Logique basique pour extraire les questions
            questions = []
            lines = response_text.split('\n')
            current_question = {}
            
            for line in lines:
                line = line.strip()
                if line.startswith('Question:'):
                    if current_question:
                        questions.append(self._create_market_question(current_question, category))
                    current_question = {'question': line.replace('Question:', '').strip()}
                elif line.startswith('√âch√©ance:') or line.startswith('Deadline:'):
                    current_question['deadline'] = line.split(':', 1)[1].strip()
                elif line.startswith('Raisonnement:') or line.startswith('Reasoning:'):
                    current_question['reasoning'] = line.split(':', 1)[1].strip()
                elif line.startswith('Mots-cl√©s:') or line.startswith('Keywords:'):
                    keywords = line.split(':', 1)[1].strip()
                    current_question['keywords'] = [k.strip() for k in keywords.split(',')]
            
            # Ajouter la derni√®re question
            if current_question:
                questions.append(self._create_market_question(current_question, category))
            
            # Si parsing √©choue, cr√©er des questions par d√©faut
            if not questions:
                questions = self._create_fallback_questions(category, count)
            
            return questions[:count]
            
        except Exception as e:
            logger.error(f"Error generating market questions: {e}")
            return self._create_fallback_questions(category, count)
    
    def _create_market_question(self, data: Dict, category: str) -> MarketQuestion:
        """Cr√©e un objet MarketQuestion √† partir des donn√©es pars√©es"""
        return MarketQuestion(
            question=data.get('question', 'Generated market question'),
            category=category,
            deadline=data.get('deadline', f'End of {datetime.now().year + 1}'),
            reasoning=data.get('reasoning', 'Based on current market trends'),
            confidence=0.7,
            relevant_keywords=data.get('keywords', [category])
        )
    
    def _create_fallback_questions(self, category: str, count: int) -> List[MarketQuestion]:
        """Cr√©e des questions de secours si la g√©n√©ration √©choue"""
        fallback_templates = {
            "Technology": [
                "Will Apple reach a $4 trillion market cap by end of 2025?",
                "Will OpenAI release GPT-5 before July 2025?",
                "Will Tesla deliver 3 million vehicles in 2025?"
            ],
            "Crypto": [
                "Will Bitcoin reach $200,000 by end of 2025?",
                "Will Ethereum surpass $10,000 before December 2025?",
                "Will a Bitcoin ETF reach $100B AUM by end of 2025?"
            ],
            "Economics": [
                "Will US inflation rate drop below 2% by end of 2025?",
                "Will the Fed cut rates below 3% in 2025?",
                "Will US GDP growth exceed 3% in 2025?"
            ]
        }
        
        templates = fallback_templates.get(category, [
            f"Will a major {category.lower()} event occur by end of 2025?",
            f"Will {category.lower()} markets reach new highs in 2025?",
            f"Will {category.lower()} innovation accelerate in 2025?"
        ])
        
        questions = []
        for i, template in enumerate(templates[:count]):
            questions.append(MarketQuestion(
                question=template,
                category=category,
                deadline=f"December 31, 2025",
                reasoning=f"Fallback question for {category} category",
                confidence=0.5,
                relevant_keywords=[category.lower()]
            ))
        
        return questions
    
    async def monitor_category_trends(self, category: str) -> str:
        """Surveille les tendances d'une cat√©gorie et sugg√®re de nouveaux march√©s"""
        questions = await self.generate_market_questions(category, 5)
        
        if self.console:
            self.console.print(f"\n[bold cyan]üìä New Market Opportunities in {category}:[/bold cyan]")
            for i, q in enumerate(questions, 1):
                self.console.print(f"{i}. {q.question}")
                self.console.print(f"   ‚îî‚îÄ Deadline: {q.deadline}")
                self.console.print(f"   ‚îî‚îÄ Confidence: {q.confidence:.1%}")
        
        summary = f"Generated {len(questions)} potential market questions for {category}:\n"
        for q in questions:
            summary += f"‚Ä¢ {q.question} (by {q.deadline})\n"
        
        return summary